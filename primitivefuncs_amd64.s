// Code generated by command: go run asm.go -out primitivefuncs_amd64.s -stubs primitivefuncs.go. DO NOT EDIT.

#include "textflag.h"

// func MACWithCarry(a uint64, b uint64, c uint64, carry uint64) (uint64, uint64)
TEXT ·MACWithCarry(SB), NOSPLIT, $0-48
	MOVQ b+8(FP), CX
	MOVQ c+16(FP), AX

	// Multiply b and c
	MULQ CX
	MOVQ a+0(FP), CX

	// Add a
	ADDQ CX, AX

	// Add to result carry if needed
	ADCQ $0x00, DX
	MOVQ carry+24(FP), CX

	// Add input carry to running result
	ADDQ CX, AX

	// Add to result carry if needed
	ADCQ $0x00, DX
	MOVQ AX, ret+32(FP)
	MOVQ DX, ret1+40(FP)
	RET

// func SubWithBorrow(a uint64, b uint64, borrow uint64) (uint64, uint64)
TEXT ·SubWithBorrow(SB), NOSPLIT, $0-40
	MOVQ a+0(FP), AX
	MOVQ b+8(FP), CX

	// a = a - b
	XORQ DX, DX
	SUBQ CX, AX

	// Zero out borrow1 and set if overflowed
	SETCS DL
	MOVQ  borrow+16(FP), CX

	// a = a - borrow
	XORQ BX, BX
	SUBQ CX, AX

	// Zero out borrow2 and set if overflowed
	SETCS BL

	// borrow2 = borrow2 | borrow1
	ORQ  DX, BX
	MOVQ AX, ret+24(FP)
	MOVQ BX, ret1+32(FP)
	RET

// func AddWithCarry(a uint64, b uint64, carry uint64) (uint64, uint64)
TEXT ·AddWithCarry(SB), NOSPLIT, $0-40
	MOVQ a+0(FP), AX
	MOVQ b+8(FP), CX
	MOVQ carry+16(FP), DX

	// Zero out new carry
	XORQ BX, BX

	// Add a + b
	ADDQ CX, AX

	// Add to new carry if needed
	ADCQ $0x00, BX

	// Add old carry
	ADDQ DX, AX

	// Add to new carry if needed
	ADCQ $0x00, BX
	MOVQ AX, ret+24(FP)
	MOVQ BX, ret1+32(FP)
	RET
