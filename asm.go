// +build ignore

package main

import (
	. "github.com/mmcloughlin/avo/build"
	. "github.com/mmcloughlin/avo/operand"
	. "github.com/mmcloughlin/avo/reg"
)

func main() {
	TEXT("MACWithCarry", NOSPLIT, "func(a, b, c, carry uint64) (uint64, uint64)")
	Doc("Finds a + b * c + carry and returns the result and the carry.")
	b := Load(Param("b"), GP64())
	c := Load(Param("c"), RAX)
	Comment("Multiply b and c")
	MULQ(b)
	a := Load(Param("a"), GP64())
	Comment("Add a")
	ADDQ(a, c)
	Comment("Add to result carry if needed")
	ADCQ(Imm(0), RDX)
	carry := Load(Param("carry"), GP64())
	Comment("Add input carry to running result")
	ADDQ(carry, c)
	Comment("Add to result carry if needed")
	ADCQ(Imm(0), RDX)
	Store(c, ReturnIndex(0))
	Store(RDX, ReturnIndex(1))
	RET()

	TEXT("SubWithBorrow", NOSPLIT, "func(a, b, borrow uint64) (uint64, uint64)")
	Doc("Finds a - b - borrow and returns the result and the borrow.")
	a = Load(Param("a"), GP64())
	b = Load(Param("b"), GP64())
	newBorrow1 := GP64()
	Comment("a = a - b")
	XORQ(newBorrow1, newBorrow1)
	SUBQ(b, a)
	Comment("Zero out borrow1 and set if overflowed")
	SETCS(newBorrow1.As8())
	borrow := Load(Param("borrow"), GP64())
	Comment("a = a - borrow")
	newBorrow2 := GP64()
	XORQ(newBorrow2, newBorrow2)
	SUBQ(borrow, a)
	Comment("Zero out borrow2 and set if overflowed")
	SETCS(newBorrow2.As8())
	Comment("borrow2 = borrow2 | borrow1")
	ORQ(newBorrow1, newBorrow2)
	Store(a, ReturnIndex(0))
	Store(newBorrow2, ReturnIndex(1))
	RET()

	TEXT("AddWithCarry", NOSPLIT, "func(a, b, carry uint64) (uint64, uint64)")
	Doc("Finds a + b + carry and returns the result and the borrow.")
	a = Load(Param("a"), GP64())
	b = Load(Param("b"), GP64())
	carry = Load(Param("carry"), GP64())
	newCarry := GP64()
	Comment("Zero out new carry")
	XORQ(newCarry, newCarry)
	Comment("Add a + b")
	ADDQ(b, a)
	Comment("Add to new carry if needed")
	ADCQ(Imm(0), newCarry)
	Comment("Add old carry")
	ADDQ(carry, a)
	Comment("Add to new carry if needed")
	ADCQ(Imm(0), newCarry)
	Store(a, ReturnIndex(0))
	Store(newCarry, ReturnIndex(1))
	RET()
	Generate()
}
